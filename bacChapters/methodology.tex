% contents:
%- used concepts
%- methods and/or models
%- languages
%- design methods
%- data models
%- analysis methods
%- formalism

\section{Plug-ins in VolumeShop}
VolumeShop is an interactive hardware-accelerated application for direct volume illustration~\cite{proc:volumeshop}. It is designed for developers to have maximum flexibility for visualization research. Its objects can be dynamically created and accessed~\cite{misc:volumeshop101}.\\
\newline
Plug-ins are functionally independent and can be dynamically loaded. One main advantage in development is that the application does not need to be closed when a plug-in is recompiled. 
\subsection{Properties}
The complete state of a plug-in is defined by its properties which constitute the plug-ins' functionality~\cite{misc:volumeshop101}. A plug-in can be easily created with the following command. \\
An example for an integer property in the range [0,255]:
\begin{lstlisting}
GetPlugin().GetProperty("Test2") = Variant::TypeInteger(12,0,255);
\end{lstlisting}

For extended functionality there is the possibility of linking properties. The change of a property causes linked properties to change as well.\\
Creating links in the GUI:
[FIGURE]
Creating links programmatically:
\begin{lstlisting}
// Link property "MyProperty" to property "LinkedProperty"
PropertyContainer::Link myLink(pTargetObject,"LinkedProperty");
GetPlugin().SetPropertyLink("MyProperty",myLink);
\end{lstlisting}

\subsection{Observers}
\label{chap:observers}
Observers allow tracking changes in properties or other objects. Notifications are being bound to member functions with the class 'ModifiedObserver'. This class notifies changes from multiple objects of different types~\cite{misc:volumeshop101}.\\
An example for using observers:
\begin{lstlisting}
// usually a class member
ModifiedObsever myObserver;

// typically in plugin constructur
// connect observer to member function
myObserver.connect(this,&MyPlugin::changed);

// add observer to objects we want to track
GetPlugin().GetProperty("MyProperty1").addObsever(&myObserver);
GetPlugin().GetProperty("MyProperty2").addObsever(&myObserver);

// notification handler
void changed(const Variant & object, const Observable::Event & event)
{
	// handle changes, e.g., trigger re-render
	GetPlugin().update();
}
\end{lstlisting}

For this work the display() function is of most importance. It is responsible for the rendering.

\subsection{Languages}
The plug-ins are written in C++ using OpenGL that is a successful cross-platform graphics application programming interface (API) for 2D and 3D computer graphics~\cite{book:computerGraphicsHill}.\\ %book: preface v
For shading and texturing OpenGL Shading Language (GLSL) is used~\cite{misc:volumeshop101}.

\section{Concept of Shaders}

In GLSL there are four different shaders:
\begin{itemize}
	\item Vertex shader
	\item Fragment shader
	\item Geometry shader
	\item Tessellation shader
\end{itemize}

The purpose of the two basic shaders, vertex shader and fragment shader, will be described in the following section.\\
\newline
In 3D computer graphics objects are described with a set of polygon surface patches and are called 'polygonal mesh' or simply 'mesh'. Each polygon has several vertices, edges and faces~\cite{book:computerGraphicsHearn}. With GLSL the shading of the polygons can be modified directly, replacing the default shading function of OpenGL.
%book: p 123, 124

\subsection{Vertex shader}
The vertex data is taken as input. A single vertex can consist of several attributes include position, color and normals.\\
The vertex shader can perform tasks such as~\cite{book:computerGraphicsHill}: %p439
\begin{itemize}
	\item transforming vertex positions
	\item transforming the normal vectors and normalizing them
	\item generating and transforming texture coordinates
	\item applying light models such as ambient, diffuse and specular per vertex
	\item computing color
\end{itemize}

\subsection{Fragment shader}	
After the vertices have been transformed into the viewplane they are rasterized. The result are fragments which contain information about screen coordinates, depth, color, texture coordinates and so on. The value of the pixel color is determined by interpolation of the vertex colors.\\
The fragment shader can perform tasks such as~\cite{book:computerGraphicsHill}: %p440
\begin{itemize}
	\item applying light values
	\item computing shadows
	\item adding complex texture(e.g. Bump Mapping)
\end{itemize}




